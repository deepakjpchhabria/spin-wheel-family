<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Family Spin The Wheel</title>
<style>
  :root{
    --bg:#0b1220; --card:#0f1724; --accent:#ffd166; --muted:#cbd5e1;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    font-family:system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial;
    background:linear-gradient(180deg,var(--bg),#071028);
    color:#fff;
    padding:18px;
  }
  .wrap{
    width:min(760px,96vw);
    background:linear-gradient(180deg,#0f1724, #071028);
    border-radius:14px;
    padding:16px;
    box-shadow:0 8px 30px rgba(2,6,23,.6);
    display:grid;
    grid-template-columns: 1fr 260px;
    gap:14px;
    align-items:center;
  }

  @media (max-width:760px){ .wrap{ grid-template-columns:1fr; } }

  /* wheel area */
  .wheel-area{ display:flex; align-items:center; justify-content:center; flex-direction:column; gap:12px; }
  .wheel-holder{ width:100%; max-width:420px; aspect-ratio:1/1; position:relative; }
  canvas{ width:100%; height:100%; display:block; border-radius:50%; }
  .pointer{
    position:absolute;
    left:50%;
    transform:translateX(-50%);
    top:-10px;
    width:0;height:0;
    border-left:16px solid transparent;
    border-right:16px solid transparent;
    border-bottom:28px solid var(--accent);
    filter:drop-shadow(0 4px 6px rgba(0,0,0,.5));
  }
  .center{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    width:84px; height:84px;
    border-radius:50%;
    display:flex; align-items:center; justify-content:center;
    background:linear-gradient(180deg,#fff,#f3f3f3);
    color:#111; font-weight:700;
    box-shadow:0 6px 18px rgba(0,0,0,.5);
    user-select:none;
  }

  /* controls */
  .controls{ padding:8px; display:flex; flex-direction:column; gap:12px; }
  .controls h2{ margin:0; font-size:18px; color:var(--muted); font-weight:600; }
  .btn{
    background:var(--accent);
    color:#111;
    border:none;
    padding:12px 14px;
    border-radius:10px;
    font-weight:700;
    font-size:16px;
    cursor:pointer;
    width:100%;
  }
  .small{ font-size:13px; color:#c9d2e6 }
  .list{ background:rgba(255,255,255,0.03); padding:10px; border-radius:8px; max-height:220px; overflow:auto; }
  .segment{ display:flex; gap:8px; align-items:center; justify-content:space-between; padding:6px 4px; border-bottom:1px dashed rgba(255,255,255,0.03); }
  .segment:last-child{ border-bottom:0; }
  input[type=text]{ width:100%; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.06); background:transparent; color:#fff; outline:none; }
  .row{ display:flex; gap:8px; }
  .muted{ color:#9fb0d1; font-size:13px; }

  footer{ grid-column:1 / -1; text-align:center; color:#9fb0d1; font-size:13px; margin-top:6px; }
</style>
</head>
<body>
<div class="wrap">
  <div class="wheel-area">
    <div class="wheel-holder" id="wheelWrap">
      <div class="pointer" aria-hidden="true"></div>
      <canvas id="wheel" width="800" height="800"></canvas>
      <div class="center" id="centerBtn">SPIN</div>
    </div>
    <div class="small" id="resultLabel"></div>
  </div>

  <div class="controls">
    <h2>Wheel segments (tap to edit, then Add)</h2>
    <div class="row">
      <input id="newSeg" type="text" placeholder="Add prize / task / name (e.g. 'Ice Cream')" />
      <button class="btn" id="addBtn" style="width:auto;padding:10px 12px">Add</button>
    </div>

    <div class="list" id="segList" aria-live="polite"></div>

    <div class="row">
      <button class="btn" id="spinBtn">SPIN</button>
      <button class="btn" id="resetBtn" style="background:#2b3440;color:#fff;width:120px">RESET</button>
    </div>

    <div class="small muted">Tips: Use 6‚Äì12 segments for best fun. You can long-press a segment in the list to remove it.</div>
  </div>

  <footer>Family Spin ‚Ä¢ Works in mobile browser ‚Ä¢ No install needed</footer>
</div>

<script>
(() => {
  // Config / state
  const defaultSegments = ['üçï Pizza','Take a selfie','Extra dessert','Do a dance','Choose someone','Skip turn','Tell a secret','Swap seat'];
  let segments = JSON.parse(localStorage.getItem('ftw_segments') || 'null') || defaultSegments.slice();
  let isSpinning = false;
  const canvas = document.getElementById('wheel');
  const ctx = canvas.getContext('2d');
  const centerBtn = document.getElementById('centerBtn');
  const wheelWrap = document.getElementById('wheelWrap');
  const spinBtn = document.getElementById('spinBtn');
  const resetBtn = document.getElementById('resetBtn');
  const addBtn = document.getElementById('addBtn');
  const newSeg = document.getElementById('newSeg');
  const segList = document.getElementById('segList');
  const resultLabel = document.getElementById('resultLabel');

  // Visuals
  let size = canvas.width;
  const radius = size/2;
  const colors = [
    '#ffb4a2','#ffd6a5','#fdffb6','#caffbf','#9bf6ff','#a0c4ff','#bdb2ff','#ffc6ff'
  ];

  // draw wheel
  function drawWheel(rotation=0){
    ctx.clearRect(0,0,size,size);
    const n = segments.length || 1;
    const angle = (2*Math.PI)/n;
    ctx.save();
    ctx.translate(radius, radius);
    ctx.rotate(rotation);
    for(let i=0;i<n;i++){
      const start = i*angle;
      // slice
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0,radius,start,start+angle);
      ctx.closePath();
      ctx.fillStyle = colors[i % colors.length];
      ctx.fill();

      // slice border
      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.lineWidth = 2;
      ctx.stroke();

      // text
      ctx.save();
      ctx.rotate(start + angle/2);
      ctx.translate(radius*0.62,0);
      ctx.rotate(Math.PI/2); // rotate text upright
      ctx.fillStyle = '#071028';
      ctx.font = 'bold 20px system-ui,Segoe UI,Roboto';
      const text = segments[i];
      // wrap long text
      wrapText(ctx, text, - (radius*0.2), -10, 140, 20);
      ctx.restore();
    }
    ctx.restore();
  }

  function wrapText(ctx, text, x, y, maxWidth, lineHeight){
    const words = text.split(' ');
    let line = '';
    let lineY = y;
    for(let n=0;n<words.length;n++){
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      if(metrics.width > maxWidth && n > 0){
        ctx.fillText(line, x, lineY);
        line = words[n] + ' ';
        lineY += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line, x, lineY);
  }

  // UI: list of segments
  function renderList(){
    segList.innerHTML = '';
    segments.forEach((s, i) => {
      const div = document.createElement('div');
      div.className = 'segment';
      div.innerHTML = `<div style="flex:1">${escapeHtml(s)}</div>
                       <div style="min-width:70px;text-align:right;color:var(--muted)"><button data-i="${i}" style="background:transparent;border:0;color:var(--muted);cursor:pointer">Edit</button>
                       <button data-del="${i}" style="background:transparent;border:0;color:#ffb4a2;cursor:pointer">Delete</button></div>`;
      segList.appendChild(div);

      // edit
      div.querySelector('button[data-i]')?.addEventListener('click', ()=> {
        const newVal = prompt('Edit segment', s);
        if(newVal !== null){
          segments[i] = newVal.trim() || s;
          saveAndRedraw();
        }
      });
      // delete
      div.querySelector('button[data-del]')?.addEventListener('click', ()=> {
        if(confirm(`Remove "${s}"?`)){
          segments.splice(i,1);
          saveAndRedraw();
        }
      });
    });
    updateResult('');
  }

  function escapeHtml(s){ return s.replace?.(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;') || s; }

  // persistence
  function saveAndRedraw(){
    localStorage.setItem('ftw_segments', JSON.stringify(segments));
    drawWheel(0);
    renderList();
  }

  // spin logic
  function spinWheel(){
    if(isSpinning) return;
    if(segments.length === 0) { alert('Add at least one segment'); return; }
    isSpinning = true;
    resultLabel.textContent = '';
    // choose random target index but with fair randomness: pick random full rotations + angle towards chosen index center
    const n = segments.length;
    const chosenIndex = Math.floor(Math.random() * n); // target slice index
    const sliceAngle = 360 / n;
    // compute target rotation in degrees: We rotate the wheel so that chosen slice center lands at pointer (top)
    // canvas drawing zero-rotation has slice 0 starting at angle 0 (to the right). We must map correctly.
    // We used rotation applied when drawing; pointer at top (270deg). We'll compute angle offset accordingly.
    const rotations = Math.floor(Math.random()*3) + 4; // 4..6 full spins
    // Angle to center of chosen slice (in degrees, wheel coordinate where 0deg is to the right). To bring slice center to top (270deg),
    // we want finalRotationDegrees such that (initialRotation + finalRotation + sliceCenter) mod 360 === 270
    // We'll just compute: target = rotations*360 + 270 - sliceCenter
    const sliceCenterDeg = (chosenIndex * sliceAngle) + (sliceAngle/2);
    const target = rotations * 360 + 270 - sliceCenterDeg;
    // animate via CSS transform on wrapper for smooth mobile GPU acceleration
    wheelWrap.style.transition = 'transform 5s cubic-bezier(.15,.9,.3,1)';
    wheelWrap.style.transform = `rotate(${target}deg)`;

    // sound: brief ticking (optional simple)
    simpleTickEffect(5);

    // after transition end
    const onEnd = () => {
      wheelWrap.style.transition = '';
      // compute final rotation degrees normalized to 0..360
      const finalDeg = target % 360;
      // draw wheel at equivalent rotation in canvas coords (convert deg to radians and invert sign because CSS rotation positive is clockwise)
      const rotationRad = (finalDeg * Math.PI/180) * -1;
      drawWheel(rotationRad);
      setTimeout(()=> {
        const winner = segments[chosenIndex];
        updateResult(`Result: ${winner}`);
        alert(`Winner: ${winner}`);
        isSpinning = false;
      }, 80);
      wheelWrap.removeEventListener('transitionend', onEnd);
    };
    wheelWrap.addEventListener('transitionend', onEnd);
  }

  function updateResult(txt){
    resultLabel.textContent = txt;
  }

  // reset
  function resetWheel(){
    if(isSpinning) return;
    if(!confirm('Reset wheel to default segments?')) return;
    segments = defaultSegments.slice();
    saveAndRedraw();
  }

  // add new segment
  addBtn.addEventListener('click', ()=>{
    const v = newSeg.value.trim();
    if(!v) return;
    segments.push(v);
    newSeg.value = '';
    saveAndRedraw();
  });
  newSeg.addEventListener('keydown', (e)=>{
    if(e.key === 'Enter') addBtn.click();
  });

  // spin button & center button
  spinBtn.addEventListener('click', spinWheel);
  centerBtn.addEventListener('click', spinWheel);

  resetBtn.addEventListener('click', resetWheel);

  // initial draw
  drawWheel(0);
  renderList();

  // helper: simple tick sound effect using WebAudio (short sequence)
  function simpleTickEffect(repeat){
    if(!window.AudioContext) return;
    try{
      const ac = new (window.AudioContext || window.webkitAudioContext)();
      const now = ac.currentTime;
      let t = 0;
      for(let i=0;i<repeat;i++){
        const o = ac.createOscillator();
        const g = ac.createGain();
        o.type = 'sine';
        o.frequency.setValueAtTime(1200 - i*80, now + t);
        g.gain.setValueAtTime(0.0001, now + t);
        g.gain.exponentialRampToValueAtTime(0.2, now + t + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, now + t + 0.09);
        o.connect(g); g.connect(ac.destination);
        o.start(now + t);
        o.stop(now + t + 0.11);
        t += 0.12;
      }
      // close context after sounds
      setTimeout(()=> { try{ ac.close(); }catch(e){} }, (t+0.2)*1000);
    }catch(e){}
  }

  // on load: ensure canvas high-DPI looks crisp
  function fixCanvasForDPR(){
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    const w = canvas.width;
    const h = canvas.height;
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  fixCanvasForDPR();
  drawWheel(0);

  // expose for debugging (optional)
  window.ftw = { segments, redraw: saveAndRedraw };
})();
</script>
</body>
</html>
