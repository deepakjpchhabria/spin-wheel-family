<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Family Spin The Wheel ‚Äî Responsive</title>
<style>
  :root{
    --bg:#071028; --panel:#0f1724; --accent:#ffd166; --muted:#9fb0d1;
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    font-family:system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial;
    background:linear-gradient(180deg,var(--bg),#02121b);
    color:#fff;
    padding:18px;
  }

  /* card */
  .wrap{
    width:min(980px,96vw);
    background:linear-gradient(180deg,#071028, #04101a);
    border-radius:14px;
    padding:14px;
    box-shadow:0 10px 30px rgba(2,6,23,.6);
    display:grid;
    grid-template-columns: 1fr 320px;
    gap:14px;
    align-items:start;
  }
  @media (max-width:860px){ .wrap{ grid-template-columns:1fr; } }

  /* wheel area */
  .wheel-area{ display:flex; align-items:center; justify-content:center; flex-direction:column; gap:12px; padding:6px; }
  /* FIXED RESPONSIVE WHEEL HOLDER */
  .wheel-holder {
    width: 100%;
    max-width: 360px;       /* comfortable for most phones */
    aspect-ratio: 1/1;
    position: relative;
    margin: 0 auto;
    overflow: hidden;
    touch-action: manipulation;
  }
  /* canvas must be responsive */
  canvas{
    width:100%;
    height:100%;
    display:block;
    border-radius:50%;
  }
  .pointer{
    position:absolute;
    left:50%;
    transform:translateX(-50%);
    top:-8px;
    width:0;height:0;
    border-left:16px solid transparent;
    border-right:16px solid transparent;
    border-bottom:28px solid var(--accent);
    filter:drop-shadow(0 6px 10px rgba(0,0,0,.45));
    z-index:30;
    pointer-events:none;
  }
  .center{
    position:absolute;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    width:84px; height:84px;
    border-radius:50%;
    display:flex; align-items:center; justify-content:center;
    background:linear-gradient(180deg,#fff,#f3f3f3);
    color:#111; font-weight:800;
    box-shadow:0 8px 26px rgba(0,0,0,.45);
    user-select:none;
    z-index:25;
    touch-action:manipulation;
  }
  /* controls */
  .controls{ padding:8px; display:flex; flex-direction:column; gap:12px; }
  .controls h2{ margin:0; font-size:18px; color:var(--muted); font-weight:700; }
  .btn{
    background:var(--accent);
    color:#111;
    border:none;
    padding:12px 14px;
    border-radius:10px;
    font-weight:700;
    font-size:16px;
    cursor:pointer;
    width:100%;
  }
  .small{ font-size:13px; color:#cfe3ff }
  .list{ background:rgba(255,255,255,0.03); padding:8px; border-radius:8px; max-height:260px; overflow:auto; }
  .segment{ display:flex; gap:8px; align-items:center; justify-content:space-between; padding:8px; border-bottom:1px dashed rgba(255,255,255,0.03); }
  .segment:last-child{ border-bottom:0; }
  input[type=text]{ width:100%; padding:8px; border-radius:8px; border:1px solid rgba(255,255,255,0.06); background:transparent; color:#fff; outline:none; }
  .row{ display:flex; gap:8px; }
  .muted{ color:#9fb0d1; font-size:13px; }

  footer{ grid-column:1 / -1; text-align:center; color:#9fb0d1; font-size:13px; margin-top:6px; }
</style>
</head>
<body>
<div class="wrap">
  <div class="wheel-area">
    <div class="wheel-holder" id="wheelWrap">
      <div class="pointer" aria-hidden="true"></div>
      <canvas id="wheelCanvas" width="800" height="800" aria-hidden="true"></canvas>
      <div class="center" id="centerBtn">SPIN</div>
    </div>
    <div class="small" id="resultLabel" aria-live="polite"></div>
  </div>

  <div class="controls">
    <h2>Wheel segments (tap Edit / Delete)</h2>
    <div class="row">
      <input id="newSeg" type="text" placeholder="Add prize / task / name (e.g. 'Ice Cream')" />
      <button class="btn" id="addBtn" style="width:auto;padding:10px 12px">Add</button>
    </div>

    <div class="list" id="segList"></div>

    <div class="row">
      <button class="btn" id="spinBtn">SPIN</button>
      <button class="btn" id="resetBtn" style="background:#2b3440;color:#fff;width:120px">RESET</button>
    </div>

    <div class="small muted">Tips: Use 6‚Äì12 segments for best fun. Changes save to this device.</div>
  </div>

  <footer>Family Spin ‚Ä¢ Responsive for iOS & Android ‚Ä¢ No install needed</footer>
</div>

<script>
(() => {
  // --- state & elements
  const defaultSegments = ['üçï Pizza','Take a selfie','Extra dessert','Do a dance','Choose someone','Skip turn','Tell a secret','Swap seat'];
  let segments = JSON.parse(localStorage.getItem('ftw_segments') || 'null') || defaultSegments.slice();
  let isSpinning = false;
  const canvas = document.getElementById('wheelCanvas');
  const ctx = canvas.getContext('2d');
  const wheelWrap = document.getElementById('wheelWrap');
  const centerBtn = document.getElementById('centerBtn');
  const spinBtn = document.getElementById('spinBtn');
  const resetBtn = document.getElementById('resetBtn');
  const addBtn = document.getElementById('addBtn');
  const newSeg = document.getElementById('newSeg');
  const segList = document.getElementById('segList');
  const resultLabel = document.getElementById('resultLabel');

  // visuals
  const colors = ['#ffb4a2','#ffd6a5','#fdffb6','#caffbf','#9bf6ff','#a0c4ff','#bdb2ff','#ffc6ff'];

  // --- responsive canvas handling (DPR aware)
  function fixCanvasForDPR(){
    // measure CSS size of canvas
    const rect = canvas.getBoundingClientRect();
    const cssW = Math.max(200, Math.round(rect.width));
    const cssH = Math.round(rect.height);
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    canvas.width = Math.round(cssW * dpr);
    canvas.height = Math.round(cssH * dpr);
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }

  // redraw wrapper (rotationRad in radians)
  function drawWheel(rotation = 0){
    fixCanvasForDPR();
    const w = canvas.width / (window.devicePixelRatio||1);
    const h = canvas.height / (window.devicePixelRatio||1);
    const radius = Math.min(w,h)/2;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save();
    ctx.translate(w/2, h/2);
    ctx.rotate(rotation);
    const n = Math.max(1, segments.length);
    const angle = (2*Math.PI)/n;

    for(let i=0;i<n;i++){
      const start = i*angle;
      // slice
      ctx.beginPath();
      ctx.moveTo(0,0);
      ctx.arc(0,0,radius,start,start+angle);
      ctx.closePath();
      ctx.fillStyle = colors[i % colors.length];
      ctx.fill();

      // border
      ctx.strokeStyle = 'rgba(0,0,0,0.15)';
      ctx.lineWidth = 2;
      ctx.stroke();

      // text
      ctx.save();
      ctx.rotate(start + angle/2);
      ctx.translate(radius*0.62,0);
      ctx.rotate(Math.PI/2);
      ctx.fillStyle = '#071028';
      // font size scaled by radius
      const fontSize = Math.max(12, Math.round(radius * 0.09));
      ctx.font = `bold ${fontSize}px system-ui,Segoe UI,Roboto`;
      wrapText(ctx, segments[i], - (radius*0.2), -fontSize/2, radius*0.44, fontSize + 2);
      ctx.restore();
    }
    ctx.restore();
  }

  function wrapText(ctx, text, x, y, maxWidth, lineHeight){
    const words = String(text).split(' ');
    let line = '';
    let lineY = y;
    for(let n=0;n<words.length;n++){
      const testLine = line + words[n] + ' ';
      const metrics = ctx.measureText(testLine);
      if(metrics.width > maxWidth && n > 0){
        ctx.fillText(line, x, lineY);
        line = words[n] + ' ';
        lineY += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line, x, lineY);
  }

  // --- UI list rendering
  function renderList(){
    segList.innerHTML = '';
    segments.forEach((s,i)=>{
      const div = document.createElement('div');
      div.className = 'segment';
      div.innerHTML = `<div style="flex:1;word-break:break-word">${escapeHtml(s)}</div>
                       <div style="min-width:92px;text-align:right;color:var(--muted)">
                         <button data-i="${i}" style="background:transparent;border:0;color:var(--muted);cursor:pointer">Edit</button>
                         <button data-del="${i}" style="background:transparent;border:0;color:#ffb4a2;cursor:pointer">Delete</button>
                       </div>`;
      segList.appendChild(div);
      div.querySelector('button[data-i]').addEventListener('click', ()=> {
        const nv = prompt('Edit segment', s);
        if(nv !== null){
          segments[i] = nv.trim() || s;
          saveAndRedraw();
        }
      });
      div.querySelector('button[data-del]').addEventListener('click', ()=> {
        if(confirm(`Remove "${s}"?`)){
          segments.splice(i,1);
          saveAndRedraw();
        }
      });
    });
    updateResult('');
  }

  function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  function saveAndRedraw(){
    localStorage.setItem('ftw_segments', JSON.stringify(segments));
    drawWheel(0);
    renderList();
    // reset any CSS transform so canvas and wrapper match visuals
    wheelWrap.style.transition = '';
    wheelWrap.style.transform = '';
  }

  // --- spin logic (keeps wrapper transform for animation)
  function spinWheel(){
    if(isSpinning) return;
    if(segments.length === 0){ alert('Add at least one segment'); return; }
    isSpinning = true;
    updateResult('');
    const n = segments.length;
    const chosenIndex = Math.floor(Math.random() * n);
    const sliceAngle = 360 / n;
    const rotations = Math.floor(Math.random()*3) + 4; // 4..6 full spins
    // compute degrees so chosen slice center lands at pointer (top -> 270deg)
    const sliceCenterDeg = (chosenIndex * sliceAngle) + (sliceAngle/2);
    const targetDeg = rotations * 360 + 270 - sliceCenterDeg;

    // animate wrapper (GPU accelerated)
    wheelWrap.style.transition = 'transform 4.6s cubic-bezier(.15,.9,.3,1)';
    wheelWrap.style.transformOrigin = '50% 50%';
    wheelWrap.style.transform = `rotate(${targetDeg}deg)`;

    // optional ticks
    simpleTickEffect(6);

    const onEnd = () => {
      wheelWrap.style.transition = '';
      // normalize final angle for canvas redraw: finalDeg is 0..360
      const finalDeg = ((targetDeg % 360) + 360) % 360;
      // convert to radians and invert sign for canvas rotation direction
      const rotationRad = (finalDeg * Math.PI/180) * -1;
      drawWheel(rotationRad);
      setTimeout(()=> {
        const winner = segments[chosenIndex];
        updateResult(`Result: ${winner}`);
        // small alert for clarity on iOS (can be removed if you prefer no alert)
        alert(`Winner: ${winner}`);
        isSpinning = false;
      }, 80);
      wheelWrap.removeEventListener('transitionend', onEnd);
    };
    wheelWrap.addEventListener('transitionend', onEnd);
  }

  function updateResult(txt){ resultLabel.textContent = txt; }

  function resetWheel(){
    if(isSpinning) return;
    if(!confirm('Reset wheel to default segments?')) return;
    segments = defaultSegments.slice();
    saveAndRedraw();
  }

  // add/new segment handlers
  addBtn.addEventListener('click', ()=>{
    const v = newSeg.value.trim();
    if(!v) return;
    segments.push(v);
    newSeg.value = '';
    saveAndRedraw();
  });
  newSeg.addEventListener('keydown', (e)=> { if(e.key === 'Enter') addBtn.click(); });

  // spin triggers
  spinBtn.addEventListener('click', spinWheel);
  centerBtn.addEventListener('click', spinWheel);
  resetBtn.addEventListener('click', resetWheel);

  // initial draw & resize handling
  function initialDraw(){
    fixCanvasForDPR();
    drawWheel(0);
    renderList();
  }
  initialDraw();

  // redraw on resize/orientation change (debounced)
  let rio;
  window.addEventListener('resize', ()=> { clearTimeout(rio); rio = setTimeout(()=> { fixCanvasForDPR(); drawWheel(0); }, 120); });
  window.addEventListener('orientationchange', ()=> { setTimeout(()=> { fixCanvasForDPR(); drawWheel(0); }, 200); });

  // small tick effect using WebAudio (non-blocking)
  function simpleTickEffect(repeat){
    if(!window.AudioContext) return;
    try{
      const ac = new (window.AudioContext || window.webkitAudioContext)();
      const now = ac.currentTime;
      let t = 0;
      for(let i=0;i<repeat;i++){
        const o = ac.createOscillator();
        const g = ac.createGain();
        o.type = 'sine';
        o.frequency.setValueAtTime(1200 - i*80, now + t);
        g.gain.setValueAtTime(0.0001, now + t);
        g.gain.exponentialRampToValueAtTime(0.2, now + t + 0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, now + t + 0.09);
        o.connect(g); g.connect(ac.destination);
        o.start(now + t);
        o.stop(now + t + 0.11);
        t += 0.12;
      }
      setTimeout(()=> { try{ ac.close(); }catch(e){} }, (t+0.2)*1000);
    }catch(e){}
  }

  // expose small helper for debugging (optional)
  window.ftw = { redraw: saveAndRedraw, segments };

})();
</script>
</body>
</html>